/**
 * endoflife.date
 * The endoflife.date v0 API is currently deprecated, please [use the endoflife.date v1 API](https://endoflife.date/docs/api/v1/).
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.18.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/Cycle.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

Cycle::Cycle()
{
    m_CycleIsSet = false;
    m_ReleaseDateIsSet = false;
    m_EolIsSet = false;
    m_Latest = utility::conversions::to_string_t("");
    m_LatestIsSet = false;
    m_LtsIsSet = false;
    m_SupportIsSet = false;
    m_DiscontinuedIsSet = false;
}

Cycle::~Cycle()
{
}

void Cycle::validate()
{
    // TODO: implement validation
}

web::json::value Cycle::toJson() const
{
    web::json::value val = web::json::value::object();
    if(m_CycleIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("cycle"))] = ModelBase::toJson(m_Cycle);
    }
    if(m_ReleaseDateIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("releaseDate"))] = ModelBase::toJson(m_ReleaseDate);
    }
    if(m_EolIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("eol"))] = ModelBase::toJson(m_Eol);
    }
    if(m_LatestIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("latest"))] = ModelBase::toJson(m_Latest);
    }
    if(m_Link.has_value())
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("link"))] = ModelBase::toJson(m_Link.get());
    }
    if(m_LtsIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("lts"))] = ModelBase::toJson(m_Lts);
    }
    if(m_SupportIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("support"))] = ModelBase::toJson(m_Support);
    }
    if(m_DiscontinuedIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("discontinued"))] = ModelBase::toJson(m_Discontinued);
    }

    return val;
}

bool Cycle::fromJson(const web::json::value& val)
{
    bool ok = true;
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("cycle"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("cycle")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Cycle_cycle> refVal_setCycle;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCycle);
            setCycle(refVal_setCycle);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("releaseDate"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("releaseDate")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setReleaseDate;
            ok &= ModelBase::fromJson(fieldValue, refVal_setReleaseDate);
            setReleaseDate(refVal_setReleaseDate);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("eol"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("eol")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Cycle_eol> refVal_setEol;
            ok &= ModelBase::fromJson(fieldValue, refVal_setEol);
            setEol(refVal_setEol);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("latest"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("latest")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setLatest;
            ok &= ModelBase::fromJson(fieldValue, refVal_setLatest);
            setLatest(refVal_setLatest);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("link"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("link")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setLink;
            ok &= ModelBase::fromJson(fieldValue, refVal_setLink);
            setLink(refVal_setLink);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("lts"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("lts")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Cycle_lts> refVal_setLts;
            ok &= ModelBase::fromJson(fieldValue, refVal_setLts);
            setLts(refVal_setLts);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("support"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("support")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Cycle_support> refVal_setSupport;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSupport);
            setSupport(refVal_setSupport);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("discontinued"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("discontinued")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Cycle_discontinued> refVal_setDiscontinued;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDiscontinued);
            setDiscontinued(refVal_setDiscontinued);
            
        }
    }
    return ok;
}

void Cycle::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(_XPLATSTR(".")))
    {
        namePrefix += utility::conversions::to_string_t(_XPLATSTR("."));
    }
    if(m_CycleIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("cycle")), m_Cycle));
    }
    if(m_ReleaseDateIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("releaseDate")), m_ReleaseDate));
    }
    if(m_EolIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("eol")), m_Eol));
    }
    if(m_LatestIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("latest")), m_Latest));
    }
    if(m_Link.has_value())
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("link")), m_Link.get()));
    }
    if(m_LtsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("lts")), m_Lts));
    }
    if(m_SupportIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("support")), m_Support));
    }
    if(m_DiscontinuedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("discontinued")), m_Discontinued));
    }
}

bool Cycle::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(_XPLATSTR(".")))
    {
        namePrefix += utility::conversions::to_string_t(_XPLATSTR("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("cycle"))))
    {
        std::shared_ptr<Cycle_cycle> refVal_setCycle;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("cycle"))), refVal_setCycle );
        setCycle(refVal_setCycle);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("releaseDate"))))
    {
        utility::datetime refVal_setReleaseDate;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("releaseDate"))), refVal_setReleaseDate );
        setReleaseDate(refVal_setReleaseDate);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("eol"))))
    {
        std::shared_ptr<Cycle_eol> refVal_setEol;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("eol"))), refVal_setEol );
        setEol(refVal_setEol);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("latest"))))
    {
        utility::string_t refVal_setLatest;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("latest"))), refVal_setLatest );
        setLatest(refVal_setLatest);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("link"))))
    {
        utility::string_t refVal_setLink;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("link"))), refVal_setLink );
        setLink(refVal_setLink);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("lts"))))
    {
        std::shared_ptr<Cycle_lts> refVal_setLts;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("lts"))), refVal_setLts );
        setLts(refVal_setLts);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("support"))))
    {
        std::shared_ptr<Cycle_support> refVal_setSupport;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("support"))), refVal_setSupport );
        setSupport(refVal_setSupport);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("discontinued"))))
    {
        std::shared_ptr<Cycle_discontinued> refVal_setDiscontinued;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("discontinued"))), refVal_setDiscontinued );
        setDiscontinued(refVal_setDiscontinued);
    }
    return ok;
}


std::shared_ptr<Cycle_cycle> Cycle::getCycle() const
{
    return m_Cycle;
}


void Cycle::setCycle(const std::shared_ptr<Cycle_cycle>& value)
{
    m_Cycle = value;
    m_CycleIsSet = true;
}

bool Cycle::cycleIsSet() const
{
    return m_CycleIsSet;
}

void Cycle::unsetCycle()
{
    m_CycleIsSet = false;
}
utility::datetime Cycle::getReleaseDate() const
{
    return m_ReleaseDate;
}


void Cycle::setReleaseDate(const utility::datetime& value)
{
    m_ReleaseDate = value;
    m_ReleaseDateIsSet = true;
}

bool Cycle::releaseDateIsSet() const
{
    return m_ReleaseDateIsSet;
}

void Cycle::unsetReleaseDate()
{
    m_ReleaseDateIsSet = false;
}
std::shared_ptr<Cycle_eol> Cycle::getEol() const
{
    return m_Eol;
}


void Cycle::setEol(const std::shared_ptr<Cycle_eol>& value)
{
    m_Eol = value;
    m_EolIsSet = true;
}

bool Cycle::eolIsSet() const
{
    return m_EolIsSet;
}

void Cycle::unsetEol()
{
    m_EolIsSet = false;
}
utility::string_t Cycle::getLatest() const
{
    return m_Latest;
}


void Cycle::setLatest(const utility::string_t& value)
{
    m_Latest = value;
    m_LatestIsSet = true;
}

bool Cycle::latestIsSet() const
{
    return m_LatestIsSet;
}

void Cycle::unsetLatest()
{
    m_LatestIsSet = false;
}
utility::string_t Cycle::getLink() const
{
    return m_Link.get();
}


void Cycle::setLink(const utility::string_t& value)
{
    m_Link = value;
}

bool Cycle::linkIsSet() const
{
    return m_Link.has_value();
}

void Cycle::unsetLink()
{
    m_Link.reset();
}
std::shared_ptr<Cycle_lts> Cycle::getLts() const
{
    return m_Lts;
}


void Cycle::setLts(const std::shared_ptr<Cycle_lts>& value)
{
    m_Lts = value;
    m_LtsIsSet = true;
}

bool Cycle::ltsIsSet() const
{
    return m_LtsIsSet;
}

void Cycle::unsetLts()
{
    m_LtsIsSet = false;
}
std::shared_ptr<Cycle_support> Cycle::getSupport() const
{
    return m_Support;
}


void Cycle::setSupport(const std::shared_ptr<Cycle_support>& value)
{
    m_Support = value;
    m_SupportIsSet = true;
}

bool Cycle::supportIsSet() const
{
    return m_SupportIsSet;
}

void Cycle::unsetSupport()
{
    m_SupportIsSet = false;
}
std::shared_ptr<Cycle_discontinued> Cycle::getDiscontinued() const
{
    return m_Discontinued;
}


void Cycle::setDiscontinued(const std::shared_ptr<Cycle_discontinued>& value)
{
    m_Discontinued = value;
    m_DiscontinuedIsSet = true;
}

bool Cycle::discontinuedIsSet() const
{
    return m_DiscontinuedIsSet;
}

void Cycle::unsetDiscontinued()
{
    m_DiscontinuedIsSet = false;
}

}
}
}
}


