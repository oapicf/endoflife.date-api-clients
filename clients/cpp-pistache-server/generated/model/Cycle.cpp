/**
* endoflife.date
* Documentation for the endoflife.date API. The API is currently in Alpha. Additional information about the API can be found on the [endoflife.date wiki](https://github.com/endoflife-date/endoflife.date/wiki).
*
* The version of the OpenAPI document: 0.0.1
* Contact: blah+oapicf@cliffano.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "Cycle.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

Cycle::Cycle()
{
    m_CycleIsSet = false;
    m_ReleaseDateIsSet = false;
    m_EolIsSet = false;
    m_Latest = "";
    m_LatestIsSet = false;
    m_Link = "";
    m_LinkIsSet = false;
    m_LtsIsSet = false;
    m_SupportIsSet = false;
    m_DiscontinuedIsSet = false;
    
}

void Cycle::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool Cycle::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool Cycle::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "Cycle" : pathPrefix;

             
    if (releaseDateIsSet())
    {
        const std::string& value = m_ReleaseDate;
        const std::string currentValuePath = _pathPrefix + ".releaseDate";
                
        
        if (!org::openapitools::server::helpers::validateRfc3339_date(value))
        {
            success = false;
            msg << currentValuePath << ": must be a valid RFC 3339 date-full string;";
        }

    }
             
    if (latestIsSet())
    {
        const std::string& value = m_Latest;
        const std::string currentValuePath = _pathPrefix + ".latest";
                
        
        if (value.length() < 1)
        {
            success = false;
            msg << currentValuePath << ": must be at least 1 characters long;";
        }

    }
         
    if (linkIsSet())
    {
        const std::string& value = m_Link;
        const std::string currentValuePath = _pathPrefix + ".link";
                
        
        if (value.length() < 1)
        {
            success = false;
            msg << currentValuePath << ": must be at least 1 characters long;";
        }

    }
                
    return success;
}

bool Cycle::operator==(const Cycle& rhs) const
{
    return
    
    
    
    ((!cycleIsSet() && !rhs.cycleIsSet()) || (cycleIsSet() && rhs.cycleIsSet() && getCycle() == rhs.getCycle())) &&
    
    
    ((!releaseDateIsSet() && !rhs.releaseDateIsSet()) || (releaseDateIsSet() && rhs.releaseDateIsSet() && getReleaseDate() == rhs.getReleaseDate())) &&
    
    
    ((!eolIsSet() && !rhs.eolIsSet()) || (eolIsSet() && rhs.eolIsSet() && getEol() == rhs.getEol())) &&
    
    
    ((!latestIsSet() && !rhs.latestIsSet()) || (latestIsSet() && rhs.latestIsSet() && getLatest() == rhs.getLatest())) &&
    
    
    ((!linkIsSet() && !rhs.linkIsSet()) || (linkIsSet() && rhs.linkIsSet() && getLink() == rhs.getLink())) &&
    
    
    ((!ltsIsSet() && !rhs.ltsIsSet()) || (ltsIsSet() && rhs.ltsIsSet() && getLts() == rhs.getLts())) &&
    
    
    ((!supportIsSet() && !rhs.supportIsSet()) || (supportIsSet() && rhs.supportIsSet() && getSupport() == rhs.getSupport())) &&
    
    
    ((!discontinuedIsSet() && !rhs.discontinuedIsSet()) || (discontinuedIsSet() && rhs.discontinuedIsSet() && getDiscontinued() == rhs.getDiscontinued()))
    
    ;
}

bool Cycle::operator!=(const Cycle& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const Cycle& o)
{
    j = nlohmann::json::object();
    if(o.cycleIsSet())
        j["cycle"] = o.m_Cycle;
    if(o.releaseDateIsSet())
        j["releaseDate"] = o.m_ReleaseDate;
    if(o.eolIsSet())
        j["eol"] = o.m_Eol;
    if(o.latestIsSet())
        j["latest"] = o.m_Latest;
    if(o.linkIsSet())
        j["link"] = o.m_Link;
    if(o.ltsIsSet())
        j["lts"] = o.m_Lts;
    if(o.supportIsSet())
        j["support"] = o.m_Support;
    if(o.discontinuedIsSet())
        j["discontinued"] = o.m_Discontinued;
    
}

void from_json(const nlohmann::json& j, Cycle& o)
{
    if(j.find("cycle") != j.end())
    {
        j.at("cycle").get_to(o.m_Cycle);
        o.m_CycleIsSet = true;
    } 
    if(j.find("releaseDate") != j.end())
    {
        j.at("releaseDate").get_to(o.m_ReleaseDate);
        o.m_ReleaseDateIsSet = true;
    } 
    if(j.find("eol") != j.end())
    {
        j.at("eol").get_to(o.m_Eol);
        o.m_EolIsSet = true;
    } 
    if(j.find("latest") != j.end())
    {
        j.at("latest").get_to(o.m_Latest);
        o.m_LatestIsSet = true;
    } 
    if(j.find("link") != j.end())
    {
        j.at("link").get_to(o.m_Link);
        o.m_LinkIsSet = true;
    } 
    if(j.find("lts") != j.end())
    {
        j.at("lts").get_to(o.m_Lts);
        o.m_LtsIsSet = true;
    } 
    if(j.find("support") != j.end())
    {
        j.at("support").get_to(o.m_Support);
        o.m_SupportIsSet = true;
    } 
    if(j.find("discontinued") != j.end())
    {
        j.at("discontinued").get_to(o.m_Discontinued);
        o.m_DiscontinuedIsSet = true;
    } 
    
}

org::openapitools::server::model::Cycle_cycle Cycle::getCycle() const
{
    return m_Cycle;
}
void Cycle::setCycle(org::openapitools::server::model::Cycle_cycle const& value)
{
    m_Cycle = value;
    m_CycleIsSet = true;
}
bool Cycle::cycleIsSet() const
{
    return m_CycleIsSet;
}
void Cycle::unsetCycle()
{
    m_CycleIsSet = false;
}
std::string Cycle::getReleaseDate() const
{
    return m_ReleaseDate;
}
void Cycle::setReleaseDate(std::string const& value)
{
    m_ReleaseDate = value;
    m_ReleaseDateIsSet = true;
}
bool Cycle::releaseDateIsSet() const
{
    return m_ReleaseDateIsSet;
}
void Cycle::unsetReleaseDate()
{
    m_ReleaseDateIsSet = false;
}
org::openapitools::server::model::Cycle_eol Cycle::getEol() const
{
    return m_Eol;
}
void Cycle::setEol(org::openapitools::server::model::Cycle_eol const& value)
{
    m_Eol = value;
    m_EolIsSet = true;
}
bool Cycle::eolIsSet() const
{
    return m_EolIsSet;
}
void Cycle::unsetEol()
{
    m_EolIsSet = false;
}
std::string Cycle::getLatest() const
{
    return m_Latest;
}
void Cycle::setLatest(std::string const& value)
{
    m_Latest = value;
    m_LatestIsSet = true;
}
bool Cycle::latestIsSet() const
{
    return m_LatestIsSet;
}
void Cycle::unsetLatest()
{
    m_LatestIsSet = false;
}
std::string Cycle::getLink() const
{
    return m_Link;
}
void Cycle::setLink(std::string const& value)
{
    m_Link = value;
    m_LinkIsSet = true;
}
bool Cycle::linkIsSet() const
{
    return m_LinkIsSet;
}
void Cycle::unsetLink()
{
    m_LinkIsSet = false;
}
org::openapitools::server::model::Cycle_lts Cycle::getLts() const
{
    return m_Lts;
}
void Cycle::setLts(org::openapitools::server::model::Cycle_lts const& value)
{
    m_Lts = value;
    m_LtsIsSet = true;
}
bool Cycle::ltsIsSet() const
{
    return m_LtsIsSet;
}
void Cycle::unsetLts()
{
    m_LtsIsSet = false;
}
org::openapitools::server::model::Cycle_support Cycle::getSupport() const
{
    return m_Support;
}
void Cycle::setSupport(org::openapitools::server::model::Cycle_support const& value)
{
    m_Support = value;
    m_SupportIsSet = true;
}
bool Cycle::supportIsSet() const
{
    return m_SupportIsSet;
}
void Cycle::unsetSupport()
{
    m_SupportIsSet = false;
}
org::openapitools::server::model::Cycle_discontinued Cycle::getDiscontinued() const
{
    return m_Discontinued;
}
void Cycle::setDiscontinued(org::openapitools::server::model::Cycle_discontinued const& value)
{
    m_Discontinued = value;
    m_DiscontinuedIsSet = true;
}
bool Cycle::discontinuedIsSet() const
{
    return m_DiscontinuedIsSet;
}
void Cycle::unsetDiscontinued()
{
    m_DiscontinuedIsSet = false;
}


} // namespace org::openapitools::server::model

